<!doctype html>
<html>

<head>
  <meta charsset="utf-8">
  <title></title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="manifest" href="site.webmanifest">
  <link rel="apple-touch-icon" href="icon.png">
  <!-- TODO: Place favicon.ico in the root directory -->

  <meta name="theme-color" content="#fafafa">
  <style>
    * {
      margin: 0;
      padding: 0;
      font-family: 'Courier New', Courier, monospace;
    }

    .grid {
      position: absolute;
      display: block;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      background: darkblue;
      cursor: none;
    }

    .cell {
      color: green;
      position: absolute;
      font-size: 1rem;
      letter-spacing: 0.395px; /* TODO: Explain magic number. */
    }
  </style>
</head>

<body>
  <div class="grid"></div>
  <script>
    const Cell = (char = ' ', { fgColor = 'green', bgColor = 'blue' } = {}) => ({
      char,
      fgColor,
      bgColor,
      equals: (other) => char.replace(/\w+/g, '*') == other.char.replace(/\w+/g, '*') && fgColor == other.fgColor && bgColor == other.bgColor,
      isTransperent: () => bgColor == 'blue' && !char.replace(/\s+/g, ''),
      includes: (other) => other.equals(Cell(char.slice(-1)[0], { fgColor, bgColor }))
    })

    const getCellSize = () => {
      const span = document.createElement('span')
      span.className = 'cell'
      span.innerHTML = 'X'
      document.getElementsByTagName('body')[0].appendChild(span)
      const [width, height] = [span.offsetWidth, span.offsetHeight]
      span.remove()
      return [width, height]
    }

    const setCellSize = (width, height) => {
      const css = document.createElement("style");
      css.type = "text/css";
      css.innerHTML = `.cell { width : ${width}px; height: ${height}px }`;
      document.body.appendChild(css);
    }

    const lastNotNull = (arr) => {
      let i = arr.length
      while (i-- && !arr[i]) { }
      return arr[i]
    }

    const bgCell = Cell(' ', { fgColor: 'green', bgColor: 'blue' })

    const rowReducer = (newRow, currentCell) => {
      if (!currentCell || currentCell.equals(bgCell)) {
        return [...newRow, null]
      }
      const lastCell = lastNotNull(newRow)

      if (lastCell && currentCell && lastCell.includes(currentCell)) {
        lastCell.char += currentCell.char
        return [...newRow, null]
      }

      return [...newRow, currentCell]
    }

    const gridHTML = (grid, cellWidth, cellHeight) =>
      grid.map((cells, row) =>
        cells.reduce(rowReducer, []).map((cell, col) =>
          !cell || cell.isTransperent() ?
            '' :
            `<div class="cell" style="
              background-color: ${cell.bgColor};
              color: ${cell.fgColor};
              top: ${cellHeight * row}px;
              left: ${cellWidth * col}px;
              ${cell.char.length > 1 ? `width: ${cellWidth * cell.char.length}px` : ''}
            ">
              ${cell.char}
            </div>`
        )).map(_ => _.join('')).join('')

    const mouseXYToColRow = (x, y, cellWidth, cellHeight) => [
      Math.floor(x / cellWidth),
      Math.floor(y / cellHeight)
    ]

    const memo = (f) => {
      var cache = {}
      return (...args) => {
        const key = JSON.stringify(args)
        if (cache[key]) {
          return cache[key]
        }

        const val = f(...args)
        cache[key] = val
        return val
      }
    }

    const colorToInvertedHex = memo((name) => {
      d = document.createElement("div");
      d.style.color = name;
      document.body.appendChild(d)
      const rgb = window
        .getComputedStyle(d)
        .color
        .split(/\)|,|\(/)
        .slice(1, 4)
        .map(_ => parseInt(_, 10))
      d.remove()
      const invertedRgb = [255 - rgb[0], 255 - rgb[1], 255 - rgb[2]]
      return '#' + invertedRgb
        .map(_ => _.toString(16))
        .map(hex => hex.length === 1 ? '0' + hex : hex)
        .join('')
    })

    const ifthen = (pairs) => pairs.find(_ => _[0])[1]()

    const Grid = (cols, rows) => ({

      _buttons: [],

      grid: Array(rows).fill().map(_ => Array(cols).fill().map(_ => Cell())),

      text(chars, firstCharRow, firstCharCol) {
        this.grid = this.grid.map((cells, row) => cells.map((cell, col) =>
          (firstCharRow == row && firstCharCol == col) ?
            Cell(chars, { fgColor: 'yellow' }) :
            cell))
        return this
      },

      button(bRow, bCol, text, onClick) {
        this.rect(bRow, bCol, text.length + 3, 2, {title: '', bgColor: 'darkred', borderColor: 'gray'})
        this.grid = this.grid.map((cells, row) =>
          cells.map((cell, col) =>
            ifthen([
              [row == bRow + 1 && col >= bCol + 2 && col <= bCol + 1 + text.length,
                () => Cell(text.slice(col - bCol - 2, col - bCol - 1), { fgColor: 'darkgray', bgColor: 'darkred' })],
              [true, () => cell]
            ])))
          this._buttons.push({
            leftTop: {row: bRow, col: bCol},
            rightBottom: {row: bRow + 2, col: bCol + text.length + 3},
            onClick,
          })

        return this
      },

      cursor(cursorRow, cursorCol) {
        overButton = this._buttons.find((b) => cursorRow >= b.leftTop.row && cursorRow <= b.rightBottom.row && cursorCol >= b.leftTop.col && cursorCol <= b.rightBottom.col)
        console.log('overButton', overButton)
        const invertCellColors = (cell, row, col) =>
          col == cursorCol && row == cursorRow ?
            Cell(cell.char, {
              fgColor: colorToInvertedHex(cell.fgColor),
              bgColor: colorToInvertedHex(cell.bgColor)
            }) :
            cell
        const overButtonHover = (cell, row, col) =>
          overButton && row >= overButton.leftTop.row && row <= overButton.rightBottom.row && col >= overButton.leftTop.col && col <= overButton.rightBottom.col ?
            Cell(cell.char, {
              fgColor: colorToInvertedHex(cell.fgColor),
              bgColor: colorToInvertedHex(cell.bgColor)
            }) :
            cell
        this.grid = this.grid.map(
          (cells, row) =>
            cells
              .map((cell, col) => invertCellColors(cell, row, col))
              .map((cell, col) => overButtonHover(cell, row, col))
        )
        return this
      },

      rect(topLeftRow, topLeftCol, width, height, { title, bgColor, borderColor, titleColor, shadowColor = 'black' } = {}) {
        this.grid = this.grid.map((cells, row) =>
          cells.map((cell, col) => {
            const [rRow, rCol] = [row - topLeftRow, col - topLeftCol]
            if (rRow < 0 || rCol < 0 || rRow > height + 1 || rCol > width + 1) return cell
            const titleFirstCharCol = Math.floor(width / 2 - title.length / 2)
            const borderOptions = { bgColor, fgColor: borderColor }
            return ifthen([
              // Title
              [title && rRow == 0 && rCol == titleFirstCharCol - 2,
                () => Cell('┤', borderOptions)],
              [title && rRow == 0 && rCol == titleFirstCharCol + title.length + 1,
                () => Cell('├', borderOptions)],
              [title && rRow == 0
                && rCol >= titleFirstCharCol - 1
                && rCol <= titleFirstCharCol + title.length + 1,
              () => Cell(title.slice(
                rCol - titleFirstCharCol,
                rCol - titleFirstCharCol + 1),
                { fgColor: titleColor, bgColor })],

              // Top
              [rRow == 0 && rCol == 0, () => Cell('┌', borderOptions)],
              [rRow == 0 && rCol > 0 && rCol < width, () => Cell('─', borderOptions)],
              [rRow == 0 && rCol == width, () => Cell('┐', borderOptions)],

              // Bottom
              [rRow == height && rCol == 0, () => Cell('└', borderOptions)],
              [rRow == height && rCol > 0 && rCol < width, () => Cell('─', borderOptions)],
              [rRow == height && rCol == width, () => Cell('┘', borderOptions)],

              // Sides
              [(rCol == 0 || rCol == width) && rRow < height, () => Cell('│', borderOptions)],

              // Shadow
              [rRow == 0 && rCol == width + 1, () => cell],
              [rRow == height + 1 && rCol == 0, () => cell],
              [rRow == height + 1, () => Cell(' ', { bgColor: shadowColor })],
              [rCol == width + 1, () => Cell(' ', { bgColor: shadowColor })],

              [true, () => Cell(cell.char, { fgColor: cell.fgColor, bgColor })]
            ])
          }))
        return this
      }
    })

    const [cellWidth, cellHeight] = getCellSize()
    setCellSize(cellWidth, cellHeight)
    let cursorCol, cursorRow
    const root = document.getElementsByClassName('grid')[0]
    const render = () => {
      const [cols, rows] = [
        Math.floor(Math.max(document.documentElement.clientWidth, window.innerWidth || 0) / cellWidth),
        Math.floor(Math.max(document.documentElement.clientHeight, window.innerHeight || 0) / cellHeight)
      ]

      const [rectX, rectY, rectWidth, rectHeight] = cols > 60 ?
        [Math.floor(cols / 4), Math.floor(rows / 8), Math.floor(cols / 2), Math.floor(rows / 2)] :
        [0 + 3, Math.floor(rows / 8), cols - 3 - 3, Math.floor(rows / 2)]

      const grid = window.grid = Grid(cols, rows)
        .rect(rectY, rectX, rectWidth, rectHeight, {
          title: 'Greetings curious beautiful human',
          bgColor: 'darkgray',
          borderColor: 'black',
          titleColor: 'darkred',
          shadowColor: 'black'
        })
        .button(rectY + rectHeight - 4, Math.floor(rectWidth / 2) - 17 + rectX + 2, 'CV')
        .button(rectY + rectHeight - 4, Math.floor(rectWidth / 2) - 17 + rectX + 10, 'Github')
        .button(rectY + rectHeight - 4, Math.floor(rectWidth / 2) - 17 + rectX + 22, 'Medium')
        .text(`Row: ${cursorRow === undefined ? '-' : cursorRow} Column: ${cursorCol === undefined ? '-' : cursorCol}`, rows - 1, 1)
        .cursor(cursorRow, cursorCol)
        .grid

      root.innerHTML = gridHTML(grid, cellWidth, cellHeight)
    }

    root.addEventListener('mousemove', e => {
      [cursorCol, cursorRow] = mouseXYToColRow(e.clientX, e.clientY, cellWidth, cellHeight)
      render()
    });

    window.addEventListener('resize', e => {
      render()
    });

    render()

  </script>
</body>

</html>