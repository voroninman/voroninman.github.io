<!doctype html>
<html>

<head>
  <meta charsset="utf-8">
  <title></title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="manifest" href="site.webmanifest">
  <link rel="apple-touch-icon" href="icon.png">
  <!-- Place favicon.ico in the root directory -->

  <meta name="theme-color" content="#fafafa">
  <style>
    * {
      margin: 0;
      padding: 0;
      font-family: 'Courier New', Courier, monospace;
      /* font-weight: normal; */
    }

    .grid {
      position: absolute;
      display: block;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      background: darkblue;
      cursor: none;
    }

    .cell {
      color: green;
      position: absolute;
      font-size: 1rem;
    }
  </style>
</head>

<body>
  <div class="grid"></div>
  <script>

    const Cell = (char = ' ', { fgColor = 'green', bgColor = 'blue' } = {}) => ({
      char,
      fgColor,
      bgColor,
      isTransperent: () => bgColor == 'blue' && char == ' '
    })

    const getCellSize = () => {
      const span = document.createElement('span')
      span.className = 'cell'
      span.innerHTML = 'X'
      document.getElementsByTagName('body')[0].appendChild(span)
      const [width, height] = [span.offsetWidth, span.offsetHeight]
      span.remove()
      return [width, height]
    }

    const setCellSize = (width, height) => {
      const css = document.createElement("style");
      css.type = "text/css";
      css.innerHTML = `.cell { width : ${width}px; height: ${height}px }`;
      document.body.appendChild(css);
    }

    const reduceCells = (cells) =>
      cells.reduce((prev, curr, currIdx, cells) => {
        
      })

    const gridHTML = (grid, cellWidth, cellHeight) =>
      grid.map((cells, row) =>
        cells.map((cell, col) =>
          cell.isTransperent() ?
            '' :
            [
              `<div class="cell" style="`,
              `background-color: ${cell.bgColor};`,
              `color: ${cell.fgColor};`,
              `top: ${cellHeight * row}px;`,
              `left: ${cellWidth * col}px;`,
              cell.char.length > 1 ? `width: ${cellWidth * cell.char.length}px;` : '',
              `">`,
              `${cell.char}`,
              `</div>`,
            ].join('')
        )).map(_ => _.join('')).join('')

    const mouseXYToColRow = (x, y, cellWidth, cellHeight) => [
      Math.floor(x / cellWidth),
      Math.floor(y / cellHeight)
    ]

    const colorToInvertedHex = (name) => {
      d = document.createElement("div");
      d.style.color = name;
      document.body.appendChild(d)
      const rgb = window.getComputedStyle(d).color.split(/\)|,|\(/).slice(1, 4).map(_ => parseInt(_, 10))
      d.remove()
      const invertedRgb = [255 - rgb[0], 255 - rgb[1], 255 - rgb[2]]
      return '#' + invertedRgb
        .map(_ => _.toString(16))
        .map(hex => hex.length === 1 ? '0' + hex : hex)
        .join('')
    }

    const Grid = window.Grid2 = (cols, rows) => ({

      grid: Array(rows).fill().map(_ => Array(cols).fill().map(_ => Cell())),

      text(chars, firstCharRow, firstCharCol) {
        this.grid = this.grid.map((cells, row) => cells.map((cell, col) =>
          (firstCharRow == row && firstCharCol == col) ?
            Cell(chars, { fgColor: 'yellow' }) :
            cell))
        return this
      },

      cursor(row, col) {
        this.grid = this.grid.map((cells, row) => cells.map((cell, col) =>
          col == cursorCol && row == cursorRow ?
            Cell(cell.char, { 
              fgColor: colorToInvertedHex(cell.fgColor), 
              bgColor: colorToInvertedHex(cell.bgColor) }) :
            cell))
        return this
      },

      rect(topLeftRow, topLeftCol, width, height, { title, bgColor, borderColor, titleColor, shadowColor = 'black'} = {}) {
        this.grid = this.grid.map((cells, row) =>
          cells.map((cell, col) => {
            const [rRow, rCol] = [row - topLeftRow, col - topLeftCol]
            if (rRow < 0 || rCol < 0 || rRow > height + 1 || rCol > width + 1) return cell
            const titleFirstCharCol = Math.floor(width / 2 - title.length / 2)
            const borderOptions = { bgColor, fgColor: borderColor }
            return [
              // Title
              [title && rRow == 0 && rCol == titleFirstCharCol - 2, Cell('┤', borderOptions)],
              [title && rRow == 0 && rCol == titleFirstCharCol + title.length + 1, Cell('├', borderOptions)],
              [title && rRow == 0
                && rCol >= titleFirstCharCol - 1
                && rCol <= titleFirstCharCol + title.length + 1,
              Cell(title.slice(
                rCol - titleFirstCharCol,
                rCol - titleFirstCharCol + 1),
                { fgColor: titleColor, bgColor })],

              // Top
              [rRow == 0 && rCol == 0, Cell('┌', borderOptions)],
              [rRow == 0 && rCol > 0 && rCol < width, Cell('─', borderOptions)],
              [rRow == 0 && rCol == width, Cell('┐', borderOptions)],

              // Bottom
              [rRow == height && rCol == 0, Cell('└', borderOptions)],
              [rRow == height && rCol > 0 && rCol < width, Cell('─', borderOptions)],
              [rRow == height && rCol == width, Cell('┘', borderOptions)],

              // Sides
              [(rCol == 0 || rCol == width) && rRow < height  , Cell('│', borderOptions)],

              // Shadow
              [rRow == 0 && rCol == width + 1, Cell()],
              [rRow == height + 1 && rCol == 0, Cell()],
              [rRow == height + 1, Cell(' ', {bgColor: shadowColor})],
              [rCol == width + 1, Cell(' ', {bgColor: shadowColor})],

              [true, Cell(cell.char, { fgColor: cell.fgColor, bgColor })]
            ].find(([cond, ..._]) => cond)[1]
          }))
        return this
      }
    })

    const [cellWidth, cellHeight] = getCellSize()
    setCellSize(cellWidth, cellHeight)
    let cursorCol, cursorRow
    const root = document.getElementsByClassName('grid')[0]
    const render = () => {
      const [cols, rows] = [
        Math.floor(Math.max(document.documentElement.clientWidth, window.innerWidth || 0) / cellWidth),
        Math.floor(Math.max(document.documentElement.clientHeight, window.innerHeight || 0) / cellHeight)
      ]

      const [rectX, rectY, rectWidth, rectHeight] = cols > 60 ?
        [Math.floor(cols / 4), Math.floor(rows / 8), Math.floor(cols / 2), Math.floor(rows / 2)] :
        [0 + 3, Math.floor(rows / 8), cols - 3 - 3, Math.floor(rows / 2)]

      const grid = window.grid = Grid(cols, rows)
        .rect(rectY, rectX, rectWidth, rectHeight, {
          title: 'Greetings curious beautiful human',
          bgColor: 'darkgray',
          borderColor: 'black',
          titleColor: 'darkred',
          shadowColor: 'blue'
        })
        .cursor(cursorCol, cursorRow)
        .grid

      root.innerHTML = gridHTML(grid, cellWidth, cellHeight)
    }

    root.addEventListener('mousemove', e => {
      [cursorCol, cursorRow] = mouseXYToColRow(e.clientX, e.clientY, cellWidth, cellHeight)
      render()
    });

    window.addEventListener('resize', e => {
      render()
    });

    render()

  </script>
</body>

</html>